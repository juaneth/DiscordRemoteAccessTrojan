"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("./config");
const lodash_1 = require("lodash");
const get_1 = require("./methods/get");
const post_1 = require("./methods/post");
const fsReadfilePromise = require("fs-readfile-promise");
const xml2js_1 = require("xml2js");
class PastebinAPI {
    constructor(config = null) {
        if (lodash_1.isUndefined(config) || lodash_1.isNull(config)) {
            this.config = {};
            return;
        }
        let conf = config;
        if (typeof config === 'string') {
            conf = {
                api_dev_key: config,
            };
        }
        this.config = lodash_1.extend(config_1.defaultOptions, conf);
    }
    getPaste(id, isPrivate = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (isPrivate) {
                const params = this.createParams('show_paste');
                params.api_paste_key = id;
                try {
                    yield this.createAPIuserKey();
                    params.api_user_key = this.config.api_user_key;
                    return this.postApi(config_1.ENDPOINTS.APIRAW, params);
                }
                catch (error) {
                    return Promise.reject(error);
                }
            }
            return this.getApi(config_1.ENDPOINTS.RAW + id);
        });
    }
    createPaste(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hasDevKey()) {
                return Promise.reject(new Error('Dev key needed!'));
            }
            const { text, title, format, expiration } = options;
            let { privacy } = options;
            if (lodash_1.isUndefined(privacy) || typeof privacy !== 'number') {
                privacy = config_1.PRIVACY_LEVEL.PUBLIC_ANONYMOUS;
            }
            else if (privacy > 3 || privacy < 0) {
                return Promise.reject(new Error('Privacy level can only be 0 - 3'));
            }
            const params = this.createParams('paste');
            params.api_paste_code = text;
            params.api_paste_private = privacy;
            if (typeof text !== 'string') {
                return Promise.reject(new Error('text can only be of type string!'));
            }
            if (typeof title === 'string') {
                params.api_paste_name = title;
            }
            if (typeof format === 'string') {
                if (config_1.formats[format]) {
                    params.api_paste_format = format;
                }
                else {
                    return Promise.reject(new Error(`Paste format ${options.format} is unknown!`));
                }
            }
            if (privacy === config_1.PRIVACY_LEVEL.PRIVATE || privacy === config_1.PRIVACY_LEVEL.PUBLIC_USER) {
                try {
                    yield this.createAPIuserKey();
                }
                catch (error) {
                    return Promise.reject(error);
                }
                params.api_user_key = this.config.api_user_key;
            }
            if (typeof expiration === 'string') {
                if (!lodash_1.isUndefined(config_1.expiration[expiration])) {
                    params.api_paste_expire_date = expiration;
                }
                else {
                    return Promise.reject(new Error(`Expiration format '${expiration}' is unknown!`));
                }
            }
            params.api_paste_private = privacy === config_1.PRIVACY_LEVEL.PUBLIC_USER ? config_1.PRIVACY_LEVEL.PUBLIC_ANONYMOUS : privacy;
            return this.postApi(config_1.ENDPOINTS.POST, params);
        });
    }
    createPasteFromFile(options = { file: '' }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options.file === '') {
                return Promise.reject(new Error('file is undefined'));
            }
            let data;
            try {
                data = yield fsReadfilePromise(options.file, 'utf8');
            }
            catch (error) {
                return Promise.reject(new Error(`Error reading file! ${error}`));
            }
            const pasteOpts = options;
            delete pasteOpts.file;
            pasteOpts.text = data;
            return this.createPaste(pasteOpts);
        });
    }
    deletePaste(pasteID) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hasDevKey()) {
                return Promise.reject(new Error('Dev key needed!'));
            }
            const params = this.createParams('delete');
            params.api_paste_key = pasteID;
            try {
                yield this.createAPIuserKey();
            }
            catch (error) {
                return Promise.reject(error);
            }
            params.api_user_key = this.config.api_user_key;
            return this.postApi(config_1.ENDPOINTS.POST, params);
        });
    }
    listTrending() {
        if (!this.hasDevKey()) {
            return Promise.reject(new Error('Dev key needed!'));
        }
        const params = this.createParams('trends');
        return this.postAndParse(params, this.parsePastes);
    }
    listUserPastes(limit = 50) {
        return __awaiter(this, void 0, void 0, function* () {
            if (limit < 1 || limit > 1000) {
                return Promise.reject(new Error('listUserPastes only accepts a limit between 1 and 1000'));
            }
            if (!this.hasDevKey()) {
                return Promise.reject(new Error('Dev key needed!'));
            }
            const params = this.createParams('list');
            params.api_results_limit = limit;
            try {
                yield this.createAPIuserKey();
            }
            catch (error) {
                return Promise.reject(error);
            }
            params.api_user_key = this.config.api_user_key;
            return this.postAndParse(params, this.parsePastes);
        });
    }
    getUserInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hasDevKey()) {
                return Promise.reject(new Error('Dev key needed!'));
            }
            const params = this.createParams('userdetails');
            try {
                yield this.createAPIuserKey();
            }
            catch (error) {
                return Promise.reject(error);
            }
            params.api_user_key = this.config.api_user_key;
            return this.postAndParse(params, this.parseUser);
        });
    }
    createParams(option) {
        return {
            api_option: option,
            api_dev_key: this.config.api_dev_key,
        };
    }
    createAPIuserKey() {
        const inValid = this.validateConfig('api_dev_key', 'api_user_name', 'api_user_password');
        if (typeof inValid === 'string') {
            return Promise.reject(new Error(inValid));
        }
        if (!lodash_1.isUndefined(this.config.api_user_key) && !lodash_1.isNull(this.config.api_user_key) && this.config.api_user_key !== '') {
            return Promise.resolve();
        }
        const { api_dev_key, api_user_name, api_user_password } = this.config;
        return this.postApi(config_1.ENDPOINTS.LOGIN, {
            api_dev_key,
            api_user_name,
            api_user_password,
        }).then((data) => {
            const key = data.trim();
            if (key.length !== 32) {
                return Promise.reject(new Error(`Error in creating user key: ${key}`));
            }
            this.config.api_user_key = key;
            return Promise.resolve(null);
        });
    }
    hasDevKey() {
        return this.validateConfig('api_dev_key') === false;
    }
    validateConfig(...validateKeys) {
        const missing = validateKeys.filter((key) => lodash_1.isUndefined(this.config[key]) ||
            this.config[key] === null ||
            this.config[key] === '');
        if (missing.length > 0) {
            return `The following keys are missing: ${missing.join(',')}`;
        }
        return false;
    }
    postAndParse(params, parseFunc) {
        return this.postApi(config_1.ENDPOINTS.POST, params)
            .then((data) => {
            return parseFunc.call(this, data);
        });
    }
    parsePastes(xml) {
        return this.parseXML(xml)
            .then((data) => {
            if (lodash_1.isUndefined(data) || lodash_1.isNull(data) || lodash_1.isUndefined(data.paste)) {
                throw new Error('No data returned to _parsePastes!');
            }
            return lodash_1.map(data.paste, (paste) => {
                const obj = {};
                lodash_1.forEach(lodash_1.keys(paste), (key) => {
                    obj[key] = paste[key][0];
                });
                return obj;
            });
        });
    }
    parseUser(xml) {
        return this.parseXML(xml)
            .then((data) => {
            if (lodash_1.isUndefined(data) || lodash_1.isNull(data) || lodash_1.isUndefined(data.user)) {
                throw new Error('No data returned to _parseUser!');
            }
            const rootObj = data.user[0];
            const normalize = {};
            lodash_1.forEach(lodash_1.keys(rootObj), (key) => {
                normalize[key] = rootObj[key][0];
            });
            return normalize;
        });
    }
    parseXML(xml) {
        return new Promise((resolve, reject) => {
            const parser = new xml2js_1.Parser({
                trim: true,
                explicitRoot: false,
            });
            parser.parseString(`<root>${xml}</root>`, (err, data) => {
                if (!lodash_1.isNull(err)) {
                    return reject(new Error(`Error in parsing XML: ${err}`));
                }
                resolve(data);
            });
        });
    }
    getApi(path, params) {
        return get_1.getRequest(path, params);
    }
    postApi(path, params) {
        return post_1.postRequest(path, params);
    }
}
exports.PastebinAPI = PastebinAPI;
